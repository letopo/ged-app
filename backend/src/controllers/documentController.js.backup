import { Op } from 'sequelize';
import Document from '../models/Document.js';
import User from '../models/User.js';
import fs from 'fs/promises';
import path from 'path';

export const uploadDocument = async (req, res) => {
  const { file } = req;
  const { title, description, category, tags } = req.body;

  if (!file) {
    return res.status(400).json({ success: false, error: 'Fichier manquant' });
  }

  try {
    const document = await Document.create({
      title: title || file.originalname,
      description,
      category: category || 'autre',
      tags: tags ? tags.split(',').map(t => t.trim()) : [],
      fileUrl: `/uploads/${file.filename}`,
      fileName: file.originalname,
      fileSize: file.size,
      mimeType: file.mimetype,
      uploadedBy: req.user.id
    });

    await document.reload({
      include: [{ model: User, as: 'uploader', attributes: ['id', 'firstName', 'lastName'] }]
    });

    res.status(201).json({
      success: true,
      data: document,
      message: 'Document uploadé'
    });
  } catch (error) {
    if (file) await fs.unlink(file.path).catch(console.error);
    console.error('Erreur upload:', error);
    res.status(500).json({ success: false, error: 'Erreur upload' });
  }
};

export const getDocuments = async (req, res) => {
  const { page = 1, limit = 20, category, status } = req.query;

  try {
    const where = {};
    if (category) where.category = category;
    if (status) where.status = status;
    if (req.user.role !== 'admin') where.uploadedBy = req.user.id;

    const { count, rows } = await Document.findAndCountAll({
      where,
      limit: parseInt(limit),
      offset: (parseInt(page) - 1) * parseInt(limit),
      order: [['createdAt', 'DESC']],
      include: [{ model: User, as: 'uploader', attributes: ['id', 'firstName', 'lastName'] }],
      attributes: { exclude: ['extractedText'] }
    });

    res.json({
      success: true,
      data: rows,
      pagination: {
        total: count,
        page: parseInt(page),
        pages: Math.ceil(count / parseInt(limit))
      }
    });
  } catch (error) {
    console.error('Erreur récupération:', error);
    res.status(500).json({ success: false, error: 'Erreur récupération' });
  }
};

export const getDocument = async (req, res) => {
  try {
    const document = await Document.findByPk(req.params.id, {
      include: [
        { model: User, as: 'uploader', attributes: ['id', 'firstName', 'lastName'] },
        { model: User, as: 'validator', attributes: ['id', 'firstName', 'lastName'] }
      ]
    });

    if (!document) {
      return res.status(404).json({ success: false, error: 'Document non trouvé' });
    }

    if (req.user.role !== 'admin' && document.uploadedBy !== req.user.id) {
      return res.status(403).json({ success: false, error: 'Accès refusé' });
    }

    res.json({ success: true, data: document });
  } catch (error) {
    res.status(500).json({ success: false, error: 'Erreur récupération' });
  }
};

export const updateDocument = async (req, res) => {
  const { title, description, category, tags, status } = req.body;

  try {
    const document = await Document.findByPk(req.params.id);

    if (!document) {
      return res.status(404).json({ success: false, error: 'Document non trouvé' });
    }

    if (req.user.role !== 'admin' && document.uploadedBy !== req.user.id) {
      return res.status(403).json({ success: false, error: 'Accès refusé' });
    }

    if (title) document.title = title;
    if (description) document.description = description;
    if (category) document.category = category;
    if (tags) document.tags = tags.split(',').map(t => t.trim());

    if (status && ['admin', 'manager'].includes(req.user.role)) {
      document.status = status;
      if (status === 'approved' || status === 'rejected') {
        document.validatedBy = req.user.id;
        document.validatedAt = new Date();
      }
    }

    await document.save();

    res.json({ success: true, data: document, message: 'Document mis à jour' });
  } catch (error) {
    console.error('Erreur mise à jour:', error);
    res.status(500).json({ success: false, error: 'Erreur mise à jour' });
  }
};

export const deleteDocument = async (req, res) => {
  try {
    const document = await Document.findByPk(req.params.id);

    if (!document) {
      return res.status(404).json({ success: false, error: 'Document non trouvé' });
    }

    if (req.user.role !== 'admin' && document.uploadedBy !== req.user.id) {
      return res.status(403).json({ success: false, error: 'Accès refusé' });
    }

    const filePath = path.join(process.cwd(), document.fileUrl);
    await fs.unlink(filePath).catch(console.error);
    await document.destroy();

    res.json({ success: true, message: 'Document supprimé' });
  } catch (error) {
    console.error('Erreur suppression:', error);
    res.status(500).json({ success: false, error: 'Erreur suppression' });
  }
};

export const searchDocuments = async (req, res) => {
  const { q } = req.query;

  if (!q) {
    return res.status(400).json({ success: false, error: 'Terme de recherche requis' });
  }

  try {
    const where = {
      [Op.or]: [
        { title: { [Op.iLike]: `%${q}%` } },
        { description: { [Op.iLike]: `%${q}%` } },
        { fileName: { [Op.iLike]: `%${q}%` } }
      ]
    };

    if (req.user.role !== 'admin') where.uploadedBy = req.user.id;

    const documents = await Document.findAll({
      where,
      limit: 50,
      include: [{ model: User, as: 'uploader', attributes: ['id', 'firstName', 'lastName'] }],
      attributes: { exclude: ['extractedText'] }
    });

    res.json({ success: true, data: documents, count: documents.length });
  } catch (error) {
    console.error('Erreur recherche:', error);
    res.status(500).json({ success: false, error: 'Erreur recherche' });
  }
};
